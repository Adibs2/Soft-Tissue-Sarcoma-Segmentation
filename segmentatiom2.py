# -*- coding: utf-8 -*-
"""Segmentatiom2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PaqmCyWbrNC1U636fpeIqgKD30jqW6Pz

**Code**
"""

import numpy as np
import math
from scipy import signal
import cv2
import matplotlib.pyplot as plt
from skimage import filters
import skimage

# Function to create a Gaussian kernel with a given radius
def create_gaussian_kernel(radius):
    ax = np.linspace(-(radius // 2), (radius - 1) // 2, radius)
    gauss = np.exp(-np.square(ax) / np.square(radius))
    kernel = np.outer(gauss, gauss)
    return kernel

# Function to create a rectangular ring mask
def rectangular_ring(inner_radius, outer_radius):
    diff = (outer_radius - inner_radius)
    mask = np.ones((outer_radius, outer_radius))
    mask[(diff + 1) // 2: -(diff // 2), (diff + 1) // 2: -(diff // 2)] = 0.0
    return mask

# Function to generate center and surround Gaussian kernels
def center_surround(center_radius, surround_radius):
    center_kernel = create_gaussian_kernel(center_radius)
    surround_kernel = create_gaussian_kernel(surround_radius)
    surround_kernel = surround_kernel * rectangular_ring(center_radius, surround_radius)
    center_kernel = center_kernel / np.sum(center_kernel)
    surround_kernel = surround_kernel / np.sum(surround_kernel)
    return center_kernel, surround_kernel

# Function to compute Mean Squared Relative Brightness (MSRB)
def msrb(image, center_radius_list, surround_radius_list):
    avg_brightness = np.asarray([relative_brightness(image, center_radius, surround_radius)
                                 for center_radius, surround_radius in zip(center_radius_list, surround_radius_list)])
    return np.average(avg_brightness**2, axis=0)**0.5

# Function to calculate relative brightness of the image
def relative_brightness(image, center_radius, surround_radius):
    center_kernel, surround_kernel = center_surround(center_radius, surround_radius)
    center_brightness = signal.convolve2d(image, center_kernel, mode='same', boundary='symm')
    surround_brightness = signal.convolve2d(image, surround_kernel, mode='same', boundary='symm')
    epsilon = 0.00001
    return center_brightness / (surround_brightness + epsilon)

# Function to compute Mean Squared Brightness (MSB)
def msb(image, radius_list):
    avg_brightness = [brightness(image, radius) for radius in radius_list]
    msb_list = np.asarray(avg_brightness)
    msb_image = np.average(msb_list**2, axis=0)**0.5
    return (msb_image - np.min(msb_image)) / (np.max(msb_image) - np.min(msb_image))

# Function to calculate the brightness of the image using a Gaussian kernel
def brightness(image, radius):
    kernel = create_gaussian_kernel(radius)
    kernel = kernel / np.sum(kernel)
    brightness_image = signal.convolve2d(image, kernel, mode='same', boundary='fill')
    return brightness_image

# Function to compute Mean Squared Texture (MST)
def mst(image, center_radius_list, surround_radius_list):
    avg_texture = np.asarray([texture(image, center_radius, surround_radius)
                              for center_radius, surround_radius in zip(center_radius_list, surround_radius_list)])
    return np.average(avg_texture**2, axis=0)**0.5

# Function to calculate texture of the image
def texture(image, center_radius, surround_radius):
    center_kernel, surround_kernel = center_surround(center_radius, surround_radius)
    center_texture = signal.convolve2d(image, center_kernel, mode='same', boundary='symm')
    surround_texture = signal.convolve2d(image, surround_kernel, mode='same', boundary='symm')
    return center_texture - surround_texture

# Heaviside step function for level set methods
def heaviside(level_set_function, epsilon):
    return 0.5 * (1 + 2 / np.pi * np.arctan(level_set_function / epsilon))

# Dirac delta function for level set methods
def delta(level_set_function, epsilon):
    return 1 / np.pi * epsilon / (epsilon**2 + level_set_function**2)

# Variance function for level set methods
def variance(level_set_function, image, epsilon):
    msb_list = [brightness(image, radius) for radius in rho_list]
    msb_squared_list = [brightness(image**2, radius) for radius in rho_list]
    var_list = []
    c_in, c_out = calc_mean(level_set_function, image, epsilon)
    heav = heaviside(level_set_function, epsilon)
    var_in = np.mean((heav * image - c_in)**2)
    var_out = np.mean(((1 - heav) * image - c_in)**2)
    return var_in + var_out

# Function to calculate mean inside and outside the contour
def calc_mean(level_set_function, image, epsilon):
    heav = heaviside(level_set_function, epsilon)
    c_in = np.sum(image * heav) / np.sum(heav)
    c_out = np.sum(image * (1 - heav)) / np.sum(1 - heav)
    return c_in, c_out

# Length penalty for level set methods
def length_penalty(level_set_function, mu):
    Iy, Ix = np.gradient(level_set_function)
    s = np.sqrt(Ix**2 + Iy**2)
    Ix = Ix / (s + 0.000001)
    Iy = Iy / (s + 0.000001)
    Ixx = np.gradient(Ix, axis=1)
    Iyy = np.gradient(Iy, axis=0)
    return mu * (Ixx + Iyy)

# Characteristic function penalty for level set methods
def characteristic_penalty(level_set_function, image, epsilon, lambda_list):
    c_in, c_out = calc_mean(level_set_function, image, epsilon)
    penalty = lambda_list[0] * (image - c_in)**2 + lambda_list[1] * (image - c_out)**2
    return penalty

# Function to compute characteristic images
def characteristic_images(image, radius_dict):
    msrb_radii = list(zip(*radius_dict['MSRB']))
    msrb_image = msrb(image, list(msrb_radii[0]), list(msrb_radii[1]))
    msb_image = msb(image, radius_dict['MSB'])
    mst_radii = list(zip(*radius_dict['MST']))
    mst_image = mst(image, list(mst_radii[0]), list(mst_radii[1]))
    return msrb_image, msb_image, mst_image

# Step function for level set evolution
def step(level_set_function, image, step_size, epsilon, mu, radius_dict, lambda_dict):
    msrb_image, msb_image, mst_image = characteristic_images(image, radius_dict)
    msrb_penalty = characteristic_penalty(level_set_function, msrb_image, epsilon, lambda_dict['MSRB'])
    msb_penalty = characteristic_penalty(level_set_function, msb_image, epsilon, lambda_dict['MSB'])
    mst_penalty = characteristic_penalty(level_set_function, mst_image, epsilon, lambda_dict['MST'])
    length_pen = length_penalty(level_set_function, mu)
    total_penalty = msrb_penalty + msb_penalty + mst_penalty + length_pen
    delta_function = delta(level_set_function, epsilon)
    level_set_function = level_set_function + step_size * delta_function * total_penalty
    return level_set_function

# Function to compute average of signed images
def ms_average(image_list):
    ms_avg = np.average(np.sign(image_list) * (image_list**2), axis=0)
    ms_avg = np.sign(ms_avg) * np.abs(ms_avg)**0.5
    return ms_avg

# Function to calculate results for multiple radii
def calculate_results(image, center_radius_list, surround_radius_list):
    results_list = [calculate_result(image, center_radius, surround_radius)
                    for center_radius, surround_radius in zip(center_radius_list, surround_radius_list)]
    return results_list

# Function to calculate result for given radii
def calculate_result(image, center_radius, surround_radius):
    center_kernel, surround_kernel = center_surround(center_radius, surround_radius)
    center_result = signal.convolve2d(image, center_kernel, mode='same', boundary='symm')
    surround_result = signal.convolve2d(image, surround_kernel, mode='same', boundary='symm')
    return center_result, surround_result

# Function to modify and normalize MSRB images
def modified_msrb(results_list):
    msrb_list = np.asarray([center / (surround + 0.000001) for center, surround in results_list])
    msrb_image = ms_average(msrb_list)
    return (msrb_image - np.min(msrb_image)) / (np.max(msrb_image) - np.min(msrb_image))

# Function to modify and normalize MST images
def modified_mst(results_list):
    mst_list = np.asarray([center - surround for center, surround in results_list])
    mst_image = ms_average(mst_list)
    return (mst_image - np.min(mst_image)) / (np.max(mst_image) - np.min(mst_image))

# Function to compute modified characteristic images
def modified_characteristic_images(image, radius_dict):
    msrb_radii = list(zip(*radius_dict['MSRB']))
    results_msrb = calculate_results(image, list(msrb_radii[0]), list(msrb_radii[1]))
    msrb_image = modified_msrb(results_msrb)

    mst_radii = list(zip(*radius_dict['MST']))
    results_mst = calculate_results(image, list(mst_radii[0]), list(mst_radii[1]))
    mst_image = modified_mst(results_mst)

    msb_image = msb(image, radius_dict['MSB'])
    return msrb_image, msb_image, mst_image

# Modified step function for level set evolution
def modified_step(level_set_function, feature_images, step_size, epsilon, mu, radius_dict, lambda_dict):
    msrb_penalty = characteristic_penalty(level_set_function, feature_images[0], epsilon, lambda_dict['MSRB'])
    msb_penalty = characteristic_penalty(level_set_function, feature_images[1], epsilon, lambda_dict['MSB'])
    mst_penalty = characteristic_penalty(level_set_function, feature_images[2], epsilon, lambda_dict['MST'])
    length_pen = length_penalty(level_set_function, mu)
    total_penalty = msrb_penalty + msb_penalty + mst_penalty + length_pen
    delta_function = delta(level_set_function, epsilon)
    level_set_function = level_set_function + step_size * delta_function * total_penalty
    return level_set_function

# Function to test the level set evolution
def modified_test(level_set_function, image, img, step_size, epsilon, mu, radius_dict, lambda_dict, num_iterations):
    feature_images = modified_characteristic_images(img, radius_dict)
    for i in range(num_iterations):
        level_set_function = modified_step(level_set_function, feature_images, step_size, epsilon, mu, radius_dict, lambda_dict)
        if i % 10 == 0:
            plt.imshow(image)
            plt.xticks([]), plt.yticks([])  # Hide tick values on X and Y axis
            plt.contour(level_set_function, [0], colors='r')
            plt.show(block=False)
    return level_set_function

# Parameters
mu = 1
num = 800
epsilon = 1
step_size = 5
rho_dict = {'MSRB':[(2,4),(3,6),(4,8),(5,10),(6,12),(7,14)], 'MSB':[3,4,5,6,7,8,9,10], 'MST':[(2,4),(3,6),(4,8),(5,10),(6,12),(7,14)]}
lambda_dict = {'MSRB':(-2,2), 'MSB':(-3,3), 'MST':(-2.5, 2.5)}

#'MSRB':[(3,9),(5,15),(10,30),(12,36),(15,45),(18,54),(20,60),(25,75)], 'MSB':[5,10,12,15,18,20,25], 'MST':[(5,10),(10,20),(12,24),(15,30),(18,36),(20,40),(25,50)]

# Load the image
image_path = r'/content/STS_043.png'  # Raw string to handle backslashes
# Read the image
img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)


# Initialize the level set function
IniLSF = np.ones((img.shape[0], img.shape[1]), dtype=np.float64)*-10
IniLSF[150:390, 370:550] = 1

# Initialize LSF here
LSF = IniLSF
# Convert image to RGB for display purposes
Image = cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB)

# Display the initial image with the initial contour
plt.figure(1)
plt.imshow(Image)
plt.xticks([]), plt.yticks([])  # to hide tick values on X and Y axis
contours = plt.contour(IniLSF, [0], colors='b')
#plt.setp(contours.collections, linewidth=2)  # Set linewidth for contours
plt.show(block=False)
print(LSF)

# Perform the level set evolution
LSF = mod_test(LSF, Image, img, step_size, epsilon, mu, rho_dict, lambda_dict, num)

"""**MST Image (מרקם)**"""

MSRB_MST_rho = list(zip(*rho_dict['MST']))
res_MSRB_MST = calc_res_list(img, list(MSRB_MST_rho[0]), list(MSRB_MST_rho[1]))
MST_img = mod_MST(res_MSRB_MST)
plt.imshow(MST_img)

"""**MSRB Image (בהירות יחסית)**"""

MSRB_MST_rho = list(zip(*rho_dict['MSRB']))
res_MSRB_MST = calc_res_list(img, list(MSRB_MST_rho[0]), list(MSRB_MST_rho[1]))
MSRB_img = mod_MSRB(res_MSRB_MST)
plt.imshow(MSRB_img)

"""**MSB Image (בהירות אובסולוטית)**"""

MSB_img = MSB(img, rho_dict['MSB'])
plt.imshow(MSB_img)